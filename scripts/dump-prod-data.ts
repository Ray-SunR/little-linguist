import { execSync } from 'child_process';
import * as dotenv from 'dotenv';
import * as path from 'path';
import * as fs from 'fs';
import { createClient } from '@supabase/supabase-js';

async function main() {
  const envPath = path.resolve(process.cwd(), '.env.local');
  if (fs.existsSync(envPath)) {
    dotenv.config({ path: envPath });
  } else {
    console.warn('âš ï¸  .env.local not found.');
  }

  const args = process.argv.slice(2);
  const limitIndex = args.indexOf('--limit');
  const limit = limitIndex !== -1 ? parseInt(args[limitIndex + 1], 10) : null;

  const prodDbUrl = process.env.PROD_DATABASE_URL || process.env.POSTGRES_URL_NON_POOLING || process.env.POSTGRES_URL;

  if (!prodDbUrl && !limit) {
    console.error('âŒ Error: Production database URL is not defined in .env.local');
    console.info('ðŸ’¡ Please add PROD_DATABASE_URL, POSTGRES_URL_NON_POOLING, or POSTGRES_URL to your .env.local file.');
    process.exit(1);
  }

  if (limit) {
    await dumpPartialData(limit);
  } else {
    await dumpFullData(prodDbUrl!);
  }
}

async function dumpFullData(prodDbUrl: string) {
  try {
    console.log('ðŸš€ Dumping production data to supabase/seed.sql (Full Mode)...');
    
    const command = [
      'npx supabase db dump',
      `--db-url "${prodDbUrl}"`,
      '--data-only',
      '--schema public',
      '--exclude public.book_voiceovers',
      '-f supabase/seed.sql'
    ].join(' ');

    execSync(command, { stdio: 'inherit' });
    
    console.log('âœ… Successfully generated supabase/seed.sql with production data.');
  } catch (error) {
    console.error('âŒ Failed to dump production data:', error);
    process.exit(1);
  }
}

async function dumpPartialData(limit: number) {
  const PROD_URL = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
  const PROD_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!PROD_URL || !PROD_KEY) {
    console.error('âŒ Error: SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are required for partial sync.');
    process.exit(1);
  }

  console.log(`ðŸš€ Dumping partial production data (limit: ${limit}) to supabase/seed.sql...`);

  const supabase = createClient(PROD_URL, PROD_KEY);

  try {
    const sqlStatements: string[] = [];
    sqlStatements.push('-- Partial Seed Data generated by dump-prod-data.ts');
    sqlStatements.push('SET session_replication_role = replica;');

    await appendTableData(supabase, 'subscription_plans', sqlStatements);
    await appendTableData(supabase, 'badges', sqlStatements);
    await appendTableData(supabase, 'word_insights', sqlStatements);

    console.log(`ðŸ“¦ Fetching ${limit} books...`);
    const { data: books, error: booksError } = await supabase.from('books').select('*').limit(limit);
    if (booksError) throw booksError;
    if (books) {
      sqlStatements.push(generateInsertStatement('books', books));
      const bookIds = books.map(b => b.id);

      console.log('ðŸ“¦ Fetching related book content, audio, and media...');
      await appendTableData(supabase, 'book_contents', sqlStatements, { column: 'book_id', values: bookIds });
      await appendTableData(supabase, 'book_audios', sqlStatements, { column: 'book_id', values: bookIds });
      await appendTableData(supabase, 'book_media', sqlStatements, { column: 'book_id', values: bookIds });
    }

    console.log(`ðŸ“¦ Fetching ${limit} stories...`);
    const { data: stories, error: storiesError } = await supabase.from('stories').select('*').limit(limit);
    if (storiesError) throw storiesError;
    if (stories && stories.length > 0) {
      sqlStatements.push(generateInsertStatement('stories', stories));
      
      const childIds = [...new Set(stories.map(s => s.child_id).filter(Boolean))];
      if (childIds.length > 0) {
        console.log('ðŸ“¦ Fetching referenced children...');
        const { data: children, error: childrenError } = await supabase.from('children').select('*').in('id', childIds);
        if (childrenError) throw childrenError;
        if (children && children.length > 0) {
          sqlStatements.push(generateInsertStatement('children', children));
        }
      }
    }

    const allOwnerIds = [
      ...(books?.map(b => b.owner_user_id) || []),
      ...(stories?.map(s => s.owner_user_id) || [])
    ].filter(Boolean);
    const uniqueOwnerIds = [...new Set(allOwnerIds)];
    
    if (uniqueOwnerIds.length > 0) {
      console.log('ðŸ“¦ Fetching referenced profiles...');
      const { data: profiles, error: profilesError } = await supabase.from('profiles').select('*').in('id', uniqueOwnerIds);
      if (profilesError) throw profilesError;
      if (profiles && profiles.length > 0) {
        sqlStatements.push(generateInsertStatement('profiles', profiles));
      }
    }

    sqlStatements.push('SET session_replication_role = DEFAULT;');

    fs.writeFileSync(path.resolve(process.cwd(), 'supabase/seed.sql'), sqlStatements.join('\n\n'));
    console.log('âœ… Successfully generated supabase/seed.sql with partial production data.');
  } catch (error) {
    console.error('âŒ Failed to dump partial production data:', error);
    process.exit(1);
  }
}

async function appendTableData(
  supabase: any,
  table: string,
  statements: string[],
  filter?: { column: string; values: any[] },
  limit?: number
) {
  console.log(`ðŸ“¦ Fetching data for ${table}...`);
  let query = supabase.from(table).select('*');
  
  if (filter) {
    query = query.in(filter.column, filter.values);
  }
  
  if (limit) {
    query = query.limit(limit);
  }

  const { data, error } = await query;
  if (error) throw error;
  if (data && data.length > 0) {
    statements.push(generateInsertStatement(table, data));
  }
}

function generateInsertStatement(table: string, data: any[]): string {
  if (data.length === 0) return '';

  const columns = Object.keys(data[0]);
  const values = data.map(row => {
    const rowValues = columns.map(col => {
      const val = row[col];
      if (val === null) return 'NULL';
      if (Array.isArray(val)) {
        if (table === 'books' && col === 'embedding') {
          return `'[${val.join(',')}]'`;
        }
        const jsonbColumns = ['tokens', 'timings', 'metadata', 'sections', 'quotas', 'learning_objectives', 'earned_badges', 'examples', 'raw_response', 'generation_logs', 'avatar_paths', 'library_settings', 'details', 'summary'];
        if (val.length > 0 && typeof val[0] === 'string' && !jsonbColumns.includes(col)) {
          return `ARRAY[${val.map(v => `'${String(v).replace(/'/g, "''")}'`).join(', ')}]`;
        }
        return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
      }
      if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
      if (typeof val === 'object') return `'${JSON.stringify(val).replace(/'/g, "''")}'`;
      return val;
    });
    return `(${rowValues.join(', ')})`;
  });

  return `INSERT INTO public.${table} (${columns.join(', ')}) VALUES\n${values.join(',\n')}\nON CONFLICT DO NOTHING;`;
}

main();
